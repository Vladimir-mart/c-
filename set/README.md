### Set (Y баллов)

#### Часть 1. Контейнер Set

В этой подзадаче вам нужно реализовать упрощенный аналог класса std::set под названием Set. Ваш Set должен иметь два шаблонных параметра: `Key` - тип, хранящийся в Set и `C` - сравнение на отношение "строго меньше", определяющее линейный порядок на элементах типа `Key`. 
Гарантируется, что в тестах все порядки будут линейными. Заметьте, ваш Set должен уметь работать без уточнения второго шаблонного параметра с типами, для которых есть оператор сравнения меньше (и только он). Для этого загляните в `functional`, там есть полезное для вас решение.

В данной задаче предполагается, что вы сами выбираете, какое дерево поиска использовать. Если используете декартово, то ознакомьтесь с тем, как _правильно_ генерировать псевдослучайные числа. Для этого изучите API `std::mt19337` и `std::uniform_distribution`.

Заметьте, мы делаем не аналог `std::multiset`, а именно `std::set`, так что не нужно думать о поддержке уникальных элементов.

##### Детали реализации контейнера Set

Класс должен поддерживать следующий функционал:
* Конструктор по умолчанию - создает пустое множество (как можете догадаться, памяти не должно никакой аллоцироваться)
* Правило "трех":
    1. Конструктор копирования, выполняющий полное копирование. Должен работать за линейное время от размера Set (то есть нельзя так просто взять и вставить все элементы)
    2. Копирующий оператор присваивания, аналогично интерфейсу выше
    3. Деструктор
* Метод `Size()` - возвращает размер
* Метод `Empty()` - пуст ли контейнер
* Метод `Clear()` - очищает контейнер, но оставляет его пригодным для использования
* Метод `void Insert(const Key& elem)` - добавляет `elem` в множество
* Метод `void Erase(const Key& elem)` - удаляет элемент `elem` из множества. Если таковой отсутствует, то ничего не делать. Обратите внимание, что `std::set` умеет делать куда больше различных удалений, однако обойдемся только одним.
  
#### Часть 2. Итераторы для Set

В жизни мы привыкли работать с массивами или хотя бы с контейнерами, по которым можно проитерироваться. В случае с `std::set` очевиден порядок итерирования, однако совсем неочевидно, как это делать?

Вторая часть задачи посвящена как раз посвящена итераторам над вашим Set. Заметьте, что полное итерирование по `Set` происходит в порядке `in-order traverse`, который осуществляется рекурсивно, 
но в нашем случае мы должны умело сохранять рекурсию и уметь останавливаться в фиксированный момент. 
<details>
  <summary>Не раскрывайте этот спойлер, если хотите решить эту задачу сами и без подсказок</summary>
  Для этого вам придется моделировать стек вызова рекурсии. Он хранит, откуда вы запустились и куда шли. В вашем же
  случае совсем необязательно помнить "адреса возврата", достаточно помнить, в каком порядке вы обходили ваше дерево. Для поддержки "порядка обхода" используйте std::stack с типом State, где State - ваш самописный
  тип для хранения направления обхода (использовать bool в данном контексте запрещено, так как это неинформативно). Возможно вам хватит не структуры, а enum.
</details>

##### Детали реализации итераторов

Основная идея реализации была либо придумана вами в ходе ответов на вопросы выше или же подсмотрена вами без особых размышлений (если второе верно, то лектор по алгоритмам взгрустнул).
Вам надо реализовать `Bidirectional Iterator`, в ходе лекции по итераторам вам рассказывали API итераторов различных категорий и про `iterator_traits`, вам надо реализовать все это.

<details>
  <summary>Задумайтесь, что такое неконстантный оператор для std::set? Не открывайте подсказку, пока не осознаете:)</summary>
  Допустим у нас итератор на какой-то узел в дереве и мы меняем под ним значение. Как действовать в этом случае? Перестраивать заново дерево за линейное (или того хуже) время?
  Непозволительно долго. Удалять старый элемент и вставлять его новое значение? Тогда все имеющиеся итераторы мгновенно инвалидируются, что тоже непозволительная роскошь. Поэтому
  решим проблему, как ее решили в std::set. Неконстантные итераторы отсутствуют, но не как класс, а как явление. Задумайтесь о смысле этой фразы.
</details>

Также необходимо реализовать методы `cbegin` и `cend`, `crbegin` и `crend` для `Set`, обойдитесь без копипасты.

Реализуйте оператор меньше для лексикографического сравнения сетов.

#### Часть 3. Методы с итераторами для Set

* Методы `LowerBound(const Key& elem)` и `UpperBound(const Key& elem)`. Загляните в документацию `std::set`, чтобы прописать полную сигнатуру и понять эффект.
* Метод `Find(const Key& elem)` - загляните в документацию `std::set`, чтобы прописать полную сигнатуру и понять эффект.

**Замечания.**

1. Решение должно состоять из файлов `Set.hpp` с определением класса и `Set.cpp` с реализацией методов.

2. В этой задаче запрещается использование стандартной библиотеки C++ кроме как описанного выше. Если нужны какие-либо служебные классы или функции, реализуйте их самостоятельно.

3. Проверка устроена таким образом, что требует от вас жесткого следования принятым (выше) сигнатурам и именованиям сущностей (то есть никакие `MySet`, `superSolver3000` не пройдут). Если вы реализовали требуемый функционал не полностью или интерфейс отличается от заявленного, в ответ вы получите ошибку компиляции.

4. Если вы решили первую часть, то отправьте только ее. Если вы отправили и вторую часть, то напишите в начале файла с решением `#define PARTTWO`. Если вы сделали все три подзадачи, то вы молодец и пропишите `#define PARTTHREE` после `#define PARTTWO`

5. В тесты включены проверки функциональности (методы работают так как требует условие), проверка эффективности реализации (что значит эффективно описано выше), проверка корректности работы с памятью (утечки памяти, обращения к памяти не принадлежащей процессу будут приводить к провалу)

6. Заметьте, что методы `begin` и так далее не подходят под наш кодстайл, поэтому используйте комментарий `\\ NO LINT` перед методом, чтобы кодстайл чекер не ругался на них. *Запрещено писать их перед каждым местом, где вам что-то не нравится!!*

7. На некоторые возможные вопросы по второй части задания ответы есть в тестах:)